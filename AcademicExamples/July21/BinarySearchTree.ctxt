#BlueJ class context
comment0.target=BinarySearchTree
comment0.text=\r\n\ ArrayLists\ (or\ arrays)\ are\ very\ slow\ at\ insertions\ and\ deletions\r\n\ Because\ you\ have\ to\ change\ multiple\ index\ positions\ \r\n\ \r\n\ LinkedLists\ are\ very\ slow\ at\ retrieving\ elements,\ because\ they\ do\ not\r\n\ keep\ track\ of\ index\ positions.\ Start\ from\ the\ beginning\r\n\ \r\n\ The\ solution\ is\ to\ use\ a\ binary\ search\ tree\ to\ keep\ track\ of\ your\ data\r\n\ Adding\ elements\ to\ a\ binary\ serach\ tree\ is\ O(log(n))\ complexity,\ which\ is\ better\ than\ the\ O(n)\ complexity\r\n\ you\ get\ with\ ArrayLists\r\n\ Retrieving\ elements\ in\ a\ binary\ search\ tree\ (searching)\ is\ O(log(n))\ complexity,\ which\ is\ \ better\ than\ the\r\n\ O(n)\ complexity\ that\ you\ get\ with\ LinkedLists\r\n\ \r\n\ binary\ search\ tree\:\ a\ collection\ of\ data\ such\ that\ elements\ to\ the\ left\ of\ any\ particular\ node\ are\ "less\ than"\r\n\ that\ node\ (think\ Comparable\ interface),\ elements\ to\ the\ right\ of\ any\ node\ are\ greater\ than\ that\ node\r\n\ \r\n\ This\ is\ not\ limited\ to\ numbers.\ Think\ any\ class\ that\ implements\ the\ Comparable\ interface\r\n\ We\ could\ say\ that\ one\ Person\ is\ "less"\ than\ another\ person\r\n\ The\ objects/constituents/elements\ in\ a\ binary\ search\ tree\ are\ called\ nodes\r\n\ \r\n\ A\ binary\ search\ tree\ has\ a\ root\ node\ (a\ node\ who\ has\ no\ parents).\ Every\ node\ in\ a\ binary\ search\ tree\ can\ have\r\n\ at\ MOST\ two\ children.\r\n\ A\ node\ with\ zero\ children\ is\ called\ a\:\ leaf\ node\r\n\ \r\n\ Today,\ we'll\ figure\ out\ how\ to\ add\ nodes\ to\ a\ binary\ search\ tree\ (RECURSIVELY),\ and\ how\ to\ search\ for\ an\ elemet\r\n\ in\ a\ binary\ search\ tree\ (Left\ or\ right?\ Left\ or\ right?\ Left\ or\ right?)\r\n\ \r\n\ Tonight\:\ studied\ the\ concept\ of\ binary\ search\ trees,\ figured\ out\ how\ to\ add\ nodes\r\n\ studied\ the\ difference\ in\ time\ complexity\ for\ binary\ search\ vs\ linear\ search,\ applying\ the\ concept\ to\ trees\r\n\ \r\n\ Next\ time\:\ brief\ review\ (user\ input\ example\ -->\ or\ homework),\ heaps\ -->\ priority\ queues\r\n\ \r\n
comment1.params=myNodes
comment1.target=BinarySearchTree(Node[])
comment10.params=toFind
comment10.target=int\ linearSearch(Node)
comment11.params=pizza
comment11.target=int\ binarySearch(int)
comment12.params=toFind
comment12.target=int\ binarySearch(Node)
comment13.params=root\ toFind
comment13.target=int\ binarySearch(Node,\ Node)
comment13.text=\r\n\ We\ produce\ a\ function\ that\ determines\ how\ many\ steps\ it\ takes\ the\ binary\ search\ tree\ to\ search\ for\ a\ \r\n\ particular\ element\ within\ the\ tree\r\n\ \r\n\ @param\ root\ the\ root\ to\ start\ at\ with\ the\ binary\ search\ (this\ will\ change\ with\ multiple\ runs\ of\ the\ method)\r\n\ @param\ toFind\ the\ node\ whose\ value\ you\ are\ searching\ for\r\n\ @return\ the\ number\ of\ steps\ required\ to\ find\ that\ node\r\n
comment2.params=myVals
comment2.target=BinarySearchTree(int[])
comment3.params=newNode
comment3.target=Node\ addNode(Node)
comment4.params=nodeVal
comment4.target=Node\ addNode(int)
comment5.params=currentRoot\ newNode
comment5.target=Node\ addNode(Node,\ Node)
comment5.text=\r\n\ Recursive\ implementation.\ Given\ a\ local\ "root"\ node\ (think\ of\ it\ as\ a\ parent\ in\ general,\ or\ the\ actual\ root\r\n\ if\ there's\ no\ tree\ yet)\ and\ a\ new\ node\ to\ add,\ put\ the\ node\ in\ the\ correct\ place\r\n\ \r\n\ @param\ root\r\n\ @param\ newNode\r\n\ @return\ \r\n
comment6.params=root
comment6.target=void\ printAscending(Node)
comment7.params=args
comment7.target=void\ main(java.lang.String[])
comment7.text=\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 48\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ 36\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 49\r\n\ \ \ \ 22\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 41\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 50\r\n\ \ \ \ \ \ \ \ \ 28\ \ \ \ \ \ \ \ 40\r\n
comment8.params=
comment8.target=void\ tester()
comment9.params=t
comment9.target=int\ linearSearch(int)
numComments=14
